[[Property:uuid|EA781CE6-3452-4EEF-BF05-47D94FC88A3D]]
[[Property:weight|3]]
[[Property:title|Persistence, storage, and retrieval]]
Most object-oriented applications need the ability to store object structures on persistent storage for later retrieval, and to transfer such object structures to other applications.

==Persistence completeness==

A fundamental requirement on object persistence mechanisms is the ''Persistence Completeness'' rule, stated as follows in ''[[Eiffel: The Language]]'':

Whenever an object is stored into an external file, the stored content contains all the dependents of that object. Conversely, retrieving a previously stored object also retrieves all its dependents.

Storing an object just by itself would usually result in wrong semantics: most objects contain references to other objects, which must also be stored and retrieved with it. The persistence completeness rule ensures that this is always the case. It also means, of course, that features used for storing and retrieving objects must do much more than simple input and output; they must perform complete traversals of object structures. 

==Varieties of store operations==

Different variants of the store operation are supported: '''session''', '''basic''' and '''independent''' store

* '''Session''' store produces the most compact structure in the resulting files; but the resulting structure is dependent on the current execution of the system which executes the store operation (''System'' is taken here, as elsewhere in this documentation, in its Eiffel sense of an executable assembly of classes, compiled together with the help of a configuration file.)

* '''Basic''' store is like session store with the difference that the resulting structure is dependent on the system which executes the store operation (i.e. only the system creating the storable can retrieve it.)

* On the other hand, '''independent''' store allows a system running on a computer with a certain architecture to retrieve, without any explicit conversion operation, object structures stored by a system running on a machine of a completely different architecture. In addition, independent store lets you retrieve an old version of the object that was saved (see more details in the recoverable section below.)

==Using the storage and retrieval facilities==

Historically, the persistence mechanism was offered via the helper class [[ref:libraries/base/reference/storable_chart|STORABLE]] which you could use as an ancestor whenever you wanted to store and retrieve objects. Via this class you would have access to <eiffel>basic_store</eiffel> and <eiffel>independent_store</eiffel> to store an object, and <eiffel>retrieved</eiffel> to retrieve one. However this was not necessary and the persistence mechanism could be used directly from any descendants of the [[ref:libraries/base/reference/io_medium_chart|IO_MEDIUM]] using routines with the same names. This manner of storing and retrieving objects is called the '''C''' persistence mechanism since it was completely written in C and is included as part of the Eiffel runtime.

Today, we recommend you to use the '''SED''' persistence mechanism, entirely written in Eiffel. It is very flexible as it lets you control the format of storables but most users will use its helper class [[ref:libraries/base/reference/sed_storable_facilities_chart|SED_STORABLE_FACILITIES]]. This class offers <eiffel>session_store</eiffel>, <eiffel>basic_store</eiffel>, and <eiffel>store</eiffel> (the de-facto independent store), as well as <eiffel>retrieved</eiffel>.

==Retrieval==

You only need to be aware of the difference between the various storing mechanism (session, basic and independent) at storage time. The stored structure will always be available through feature retrieved; this feature will figure out, from the format of the stored structure how it was stored and will decode it accordingly.

{{Caution|The above is only true when using just the '''C''' storable or the '''SED''' storable. If it was stored using the '''C''' storable, you need to use the '''C''' retrieved feature. Conversely, if it was stored using '''SED''', you need to use the '''SED''' retrieval mechanism.}}

Regardless of the mechanism used, the feature <eiffel>retrieved</eiffel> returns a result of type [[ref:libraries/base/reference/any_chart|detachable ANY]] and is typically used through an object test.

When using the '''C''' storable mechanis, your code would look like:
<code>
if attached {MY_TYPE} io_medium.retrieved as data then 
    -- Retrieved result is of expected type.
    -- Proceed with processing of result,
    -- typically with calls of the form `data.some_feature'.
else
    -- Result was not of expected type MY_TYPE.
end
</code>

Or when using SED:
<code>
if attached {MY_TYPE} retrieved (a_reader, false) as data then 
    -- Retrieved result is of expected type.
    -- Proceed with processing of result,
    -- typically with calls of the form `data.some_feature'.
else
    -- Result was not of expected type MY_TYPE.
end
</code>

The object test is necessary because <eiffel>retrieved</eiffel> returns a result of type [[ref:libraries/base/reference/any_chart|detachable ANY]] whereas the code will expect an object of a specific type to continue its execution.

If the structure in the file has been corrupted and <eiffel>retrieved</eiffel> is unable to do its job, it will either:
* trigger an exception in the case of '''C''' storable (the code for that exception in class [[ref:libraries/base/reference/exceptions_chart|EXCEPTIONS]] (which inherits it from EXCEP_CONST and is discussed in the next section, together with the notion of exception code) is <eiffel>Retrieve_exception</eiffel>.)
* not return an object and instead will flag the error(s) in <eiffel>retrieved_errors</eiffel>.

==Recoverable storable==

Sometimes you will be in a position where the schema of a class will have changed between the time you stored your object and the time you are trying to retrieve it. Such changes include:
* class name changed 
* attributes have been added or removed 
* attributes have been renamed 
* attributes type have been changed

The storable mechanism allows you to retrieve the old version of the object only if it was saved using the <eiffel>independent_store</eiffel> facility. Each time you retrieve an object of a certain base class whose schema has changed, the feature <eiffel>correct_mismatch</eiffel> will be called. This feature is defined in [[ref:libraries/base/reference/any_chart|ANY]] and by default will raise an exception. To handle the mismatch, you need to redefine <eiffel>correct_mismatch</eiffel> in the base class whose schema has been changed. For example in EiffelBase, [[ref:libraries/base/reference/hash_table_chart|HASH_TABLE]] has changed between version 5.1 and version 5.2 to use <eiffel> SPECIAL</eiffel> rather than [[ref:libraries/base/reference/array_chart|ARRAY]] for its internal data storage. To retrieve a 5.1 version of [[ref:libraries/base/reference/hash_table_chart|HASH_TABLE]], you need to define <eiffel>correct_mismatch</eiffel> as following: 
<code>
correct_mismatch
            -- Attempt to correct object mismatch during retrieve using `mismatch_information'.
    do
                -- In version 5.1 and earlier, `content', `keys' and `deleted_marks'
                -- were of base class ARRAY. In 5.2 we changed it to be a SPECIAL for
                -- efficiency reasons. In order to retrieve an old HASH_TABLE we
                -- need to convert those ARRAY instances into SPECIAL instances.

                -- Convert `content' from ARRAY to SPECIAL.
            if attached {ARRAY [G]} mismatch_information.item ("content") as l_temp then
                content := l_temp.area
            end

                -- Convert `keys' from ARRAY to SPECIAL.
            if attached {ARRAY [H]} mismatch_information.item ("keys") as l_temp then
                keys := l_temp.area
            end

                -- Convert `deleted_marks' from ARRAY to SPECIAL.
            if attached {ARRAY [BOOLEAN]} mismatch_information.item ("deleted_marks") as l_temp then
                deleted_marks := l_temp.area
            end

            if content = Void or keys = Void or deleted_marks = Void then
                    -- Could not retrieve old version of HASH_TABLE. We throw an exception.
                Precursor {TABLE}
            end
    end
</code>

Note the use of <eiffel>mismatch_information</eiffel>, this is a once feature of [[ref:libraries/base/reference/any_chart|ANY]] of type <eiffel>MISMATCH_INFORMATION</eiffel> which behaves like a [[ref:libraries/base/reference/hash_table_chart|HASH_TABLE]]. The keys of the table are the names of the attributes on which a mismatch occurred and the values are the corresponding object fields as they were originally stored. In this particular case of [[ref:libraries/base/reference/hash_table_chart|HASH_TABLE]] we know that the previous version was an [[ref:libraries/base/reference/array_chart|ARRAY]], so we do an object test and if it succeeds we assign its <eiffel>area</eiffel> to the corresponding attribute of [[ref:libraries/base/reference/hash_table_chart|HASH_TABLE]]. 

If a class name changed, then you need to create an instance of <eiffel>CLASS_NAME_TRANSLATIONS</eiffel>, it behaves like a [[ref:libraries/base/reference/hash_table_chart|HASH_TABLE]] where the keys represent the old name, and the value the new name. This instance needs to be created before the call to retrieved.
