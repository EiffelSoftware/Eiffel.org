[[Property:uuid|7CCF602E-0B79-49C2-93FE-39C90CBE4E35]]
[[Property:link_title|Code Templates]]
[[Property:title|Code Templates]]
[[Property:weight|7]]

EiffelStudio editor supports `code template completion', a functionality designed to help write Eiffel code.

Code templates are described in Eiffel itself, there are some constraints to define templates that we will cover below. At the moment Code templates can only be used as part of an existing feature. Some templates will be available as global/target-less templates, it means there is not target context, so you can include a useful template inside your current feature. In other cases we will have templates that will be only available to certain context, for example if you have an <code>ARRAY [INTEGER]</code>, then you will be able to see templates applicable to it, if any.


<span id="templates_location"></span> 
==Templates location==

EiffelStudio will scan the Eiffel Templates at the EiffelStudio installation and EiffelStudio user directory.
User defined templates will have precedence over templates located at the EiffelStudio installation.


<span id="templates_definition"></span> 
==Templates Definition==
* Indexing notes at top level class
** `template_version`, it's used to select the version of the given template, if not present, it will be parsed using the latest version,
at the moment version is `1.0`
* Every template should inherit from the <code>TEMPLATE</code> class
   class ARRAY_TEMPLATE [T -> COMPARABLE] inherIt TEMPLATE [ARRAY [T]] 
* Multiple Generic Constraints is not supported
   class EXAMPLE_TEMPLATE [T -> {TYPE_1, TYPE_2}]
* A file could have multiple code templates definitions.
** Queries 
** Commands
* Code templates could be Global/Target-less or applicable to a given Context
Queries and Commands accept multiple arguments like (a:T1; b:T2; c:T3), if any, will be used as input arguments where the default values will be filled with defaults if they exist.
* Target Templates inherit from <code>TEMPLATE [T]</code>
These templates will inherit a feature `target` with the type of the context, the generic type. 
* Targetless Templates inherit from <code>TEMPLATE</code>
These templates does not have the feature `target`.
* Metadata: itâ€™s possible to add metadata to code templates using note clause 
** title: title of template, if not present we will use the name of the feature defined in the template.   
** tags: List of tags to classify the template. 
** default: use to define default values for input arguments. 

<span id="templates_skeleton"></span> 
==Templates Skeleton==

====Context templates====
The next example shows how to define a template that will be applicable to types that conforms <code>ARRAY [COMPARABLE]</code>.

EiffelStudio editor provides automatic help to use code templates, in the case of context templates, when you type a dot ('.') character after a feature name, as part of feature call auto-completion, a new option will be available by pressing <code>crtl+space</code> 
the list of available templates will be display. 

At this point a user can select an available template, to insert into the current feature, back to the list of completion possibles by pressing <code>crtl+space</code>, or just ignore and continue editing the code.

[[Image:https://www.eiffel.org/upload/target_template_1_0.png]] 

Figure 1. Auto-completion with code template option

<code>
note
    description: "[
        Code templates for Arrays of COMPARABLES.
    ]"
    template_version: "1.0"


class ARRAY_TEMPLATE [T -> COMPARABLE]

inherit
    
    TEMPLATE [ARRAY [T]]

feature  -- Templates

   maximum: T
            -- Maximum of `target' array.  
        note
            tags: "Algorithm, Maximum, ARRAY"
        do
	    across target as element loop
                Result := Result.max (element.item)
            end
        end

   slice_maximum (low, high: INTEGER): T
             -- Get the maximum of an array, 
             -- where the interval is defined by default 
             -- by array.lower |..| array.upper.
         note
             tags: "Algorithm, Maximum, ARRAY"
             default: "target.lower, target.upper"
         do
             across low |..| high as i loop
                 Result := Result.max (target [i.item])
             end
         end  
end  
</code>

====Targetless Templates====
The next example shows how to define a template that will be applicable without any specific target. 
To show the list of available targetless templates by pressing <code>crtl+space</code> you will see a new option in the list
of completion possibilities,  by pressing again <code>crtl+space</code>, the list of targetless templates will be available.

!TODO add image 

<code>
class  TEMPLATE_DIRECTORY_GLOBAL

inherit
	
	TEMPLATE 

feature -- Templates

	entries 
			-- Display entries of current directory.
		note
			title: "Entries for a directory"
			tags: "Algorithm, entries , DIRECTORY"
		local
			l_path: PATH
			l_dir: DIRECTORY
			i,j: INTEGER
		do
 
			create l_path.make_current
			create l_dir.make_with_path (l_path)

			across
				l_dir.entries as ic
			loop
				print (ic.item.name)
				io.put_new_line
			end
		end
end
</code>





